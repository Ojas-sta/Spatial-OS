<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Meta Quest HUD Control</title>
    
    <!-- Core Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>

    <style>
        :root { --quest-blue: #3b82f6; --quest-bg: rgba(20, 25, 35, 0.85); --text-light: #e2e8f0; }
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Inter', -apple-system, sans-serif; }
        
        /* VIDEO & CANVASES */
        #video-feed { position: absolute; inset: 0; z-index: 0; transform: scaleX(-1); object-fit: cover; opacity: 0.5; filter: contrast(1.1) brightness(0.8); }
        #overlay-canvas { position: absolute; inset: 0; z-index: 5; pointer-events: none; transform: scaleX(-1); }
        #scene-container { position: absolute; inset: 0; z-index: 10; }

        /* UI CONTAINER */
        #ui-layer { position: absolute; inset: 0; z-index: 20; pointer-events: none; display: flex; flex-direction: column; }

        /* TOP BAR */
        #top-bar { 
            padding: 20px; display: flex; justify-content: space-between; align-items: flex-start;
        }
        .pill-badge {
            background: rgba(255, 255, 255, 0.1); backdrop-filter: blur(10px);
            padding: 8px 16px; border-radius: 20px; border: 1px solid rgba(255,255,255,0.1);
            color: var(--text-light); font-size: 0.85rem; font-weight: 500;
            display: flex; align-items: center; gap: 8px;
        }
        .status-dot { width: 8px; height: 8px; background: #f43f5e; border-radius: 50%; box-shadow: 0 0 8px #f43f5e; transition: background 0.3s; }
        .status-dot.ready { background: #10b981; box-shadow: 0 0 8px #10b981; }

        /* CALIBRATION CENTER */
        #calib-window {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: var(--quest-bg); backdrop-filter: blur(24px);
            padding: 40px; border-radius: 24px; border: 1px solid rgba(255,255,255,0.1);
            text-align: center; max-width: 480px; width: 90%;
            pointer-events: auto; box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
            transition: opacity 0.3s, transform 0.3s;
        }
        #calib-window.hidden { opacity: 0; pointer-events: none; transform: translate(-50%, -40%) scale(0.95); }

        h2 { margin: 0 0 8px 0; color: #fff; font-size: 1.5rem; letter-spacing: -0.02em; }
        p { color: #94a3b8; margin: 0 0 30px 0; font-size: 1rem; line-height: 1.5; }

        /* GHOST HAND ANIMATION */
        .ghost-hand {
            width: 120px; height: 120px; margin: 0 auto 20px auto;
            border: 2px dashed rgba(255,255,255,0.2); border-radius: 50%;
            display: flex; justify-content: center; align-items: center;
            position: relative;
        }
        .hand-svg { width: 60px; height: 60px; fill: none; stroke: #fff; stroke-width: 2; opacity: 0.5; }
        .progress-ring {
            position: absolute; inset: -2px; border-radius: 50%;
            border: 2px solid transparent; border-top-color: var(--quest-blue);
            transition: transform 0.1s linear; display: none;
        }

        button {
            background: #fff; color: #0f172a; border: none; padding: 12px 32px;
            border-radius: 12px; font-weight: 600; font-size: 0.95rem; cursor: pointer;
            transition: all 0.2s;
        }
        button:hover { background: #f1f5f9; transform: translateY(-1px); }

        /* BOTTOM HUD */
        #hud-bottom {
            margin-top: auto; padding: 40px;
            display: flex; justify-content: center; gap: 24px;
        }
        .data-card {
            background: rgba(15, 23, 42, 0.6); backdrop-filter: blur(12px);
            border: 1px solid rgba(255,255,255,0.05); border-radius: 16px;
            padding: 16px 20px; min-width: 140px;
            transform: translateY(20px); opacity: 0; transition: all 0.5s;
        }
        .data-card.visible { transform: translateY(0); opacity: 1; }
        .card-label { font-size: 0.75rem; text-transform: uppercase; letter-spacing: 0.05em; color: #64748b; margin-bottom: 4px; }
        .card-value { font-size: 1.25rem; font-weight: 600; color: #f8fafc; font-variant-numeric: tabular-nums; }
        .bar-bg { height: 4px; background: rgba(255,255,255,0.1); margin-top: 8px; border-radius: 2px; overflow: hidden; }
        .bar-fill { height: 100%; background: var(--quest-blue); width: 50%; transition: width 0.1s; }

        /* VIDEO SOURCE (HIDDEN) */
        video { display: none; }
    </style>
</head>
<body>

    <video id="input-video" playsinline muted></video>
    <canvas id="video-feed"></canvas>
    <canvas id="overlay-canvas"></canvas>
    <div id="scene-container"></div>

    <div id="ui-layer">
        <div id="top-bar">
            <div class="pill-badge"><div class="status-dot" id="sys-dot"></div> <span id="sys-text">System Idle</span></div>
        </div>

        <div id="calib-window">
            <div class="ghost-hand">
                <div class="progress-ring" id="calib-ring"></div>
                <!-- Simple Hand Icon SVG -->
                <svg class="hand-svg" viewBox="0 0 24 24">
                    <path d="M12 2a2 2 0 0 1 2 2v7h1a2 2 0 0 1 2 2v7a2 2 0 0 1-2 2H9a2 2 0 0 1-2-2v-7a2 2 0 0 1 2-2h1V4a2 2 0 0 1 2-2z" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
            </div>
            <h2 id="calib-title">Hand Tracking Setup</h2>
            <p id="calib-desc">Please center both hands in view to initialize the skeletal mesh system.</p>
            <button id="btn-start">Begin Calibration</button>
        </div>

        <div id="hud-bottom">
            <div class="data-card" id="card-l">
                <div class="card-label">Left Hand</div>
                <div class="card-value" id="val-shape">Sphere</div>
                <div class="bar-bg"><div class="bar-fill" style="width: 0%"></div></div>
            </div>
            <div class="data-card" id="card-r">
                <div class="card-label">Right Hand</div>
                <div class="card-value" id="val-zoom">1.0x</div>
                <div class="bar-bg"><div class="bar-fill" id="fill-zoom" style="width: 30%"></div></div>
            </div>
        </div>
    </div>

    <script>
        // --- CONFIGURATION ---
        const CONFIG = {
            SENSITIVITY: 22.0,     // Higher = snappier movement
            ZOOM_POW: 1.5,         // Exponential zoom curve
            ZOOM_MIN: 0.4,
            ZOOM_MAX: 4.5,
            SMOOTHING: 0.15,       // 0.1 = very smooth, 0.9 = raw
            MESH_COLOR: '#00e5ff',
            MESH_FILL: 'rgba(0, 229, 255, 0.05)'
        };

        // --- STATE ---
        const state = {
            phase: 'idle', // idle, calibrating, running
            calibStep: 0,
            holdProgress: 0
        };

        const phys = {
            pos: new THREE.Vector3(),
            tarPos: new THREE.Vector3(),
            zoom: 1.0,
            tarZoom: 1.0,
            rot: new THREE.Euler(),
            tarRot: new THREE.Euler(),
            shape: 'sphere'
        };

        // --- DOM ---
        const els = {
            vid: document.getElementById('input-video'),
            cvsVid: document.getElementById('video-feed'),
            cvsOver: document.getElementById('overlay-canvas'),
            calib: document.getElementById('calib-window'),
            title: document.getElementById('calib-title'),
            desc: document.getElementById('calib-desc'),
            btn: document.getElementById('btn-start'),
            ring: document.getElementById('calib-ring'),
            dot: document.getElementById('sys-dot'),
            txt: document.getElementById('sys-text'),
            cards: document.querySelectorAll('.data-card'),
            valShape: document.getElementById('val-shape'),
            valZoom: document.getElementById('val-zoom'),
            fillZoom: document.getElementById('fill-zoom')
        };

        const ctxVid = els.cvsVid.getContext('2d');
        const ctxOver = els.cvsOver.getContext('2d');

        // --- INIT ---
        async function init() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({video:{width:1280,height:720,facingMode:'user'}});
                els.vid.srcObject = stream;
                await new Promise(r => els.vid.onloadedmetadata = r);
                els.vid.play();

                // Set HiDPI Canvas
                const w = window.innerWidth; const h = window.innerHeight;
                els.cvsVid.width = w; els.cvsVid.height = h;
                els.cvsOver.width = w; els.cvsOver.height = h;

                initThree();
                initMediaPipe();
                
                els.dot.classList.add('ready');
                els.txt.innerText = "Camera Active";

                // Video Loop
                (function draw() {
                    ctxVid.drawImage(els.vid, 0, 0, w, h);
                    requestAnimationFrame(draw);
                })();

            } catch(e) {
                console.error(e);
                els.title.innerText = "Error";
                els.desc.innerText = "Camera access denied. Please refresh.";
            }
        }
        
        els.btn.addEventListener('click', () => {
            state.phase = 'calibrating';
            state.calibStep = 0;
            els.btn.style.display = 'none';
            runCalib();
        });

        init();

        // --- CALIBRATION LOGIC ---
        function runCalib() {
            const steps = [
                {t:"Left Hand", d:"Raise your Left Hand (Shape Control)"},
                {t:"Right Hand", d:"Raise your Right Hand (Navigation)"},
                {t:"Sync", d:"Hold both hands steady"}
            ];
            const s = steps[state.calibStep];
            els.title.innerText = s.t;
            els.desc.innerText = s.d;
            state.holdProgress = 0;
            els.ring.style.display = 'block';
        }

        function finishCalib() {
            state.phase = 'running';
            els.calib.classList.add('hidden');
            els.cards.forEach(c => c.classList.add('visible'));
            els.txt.innerText = "Tracking Active";
        }

        // --- MEDIAPIPE ---
        function initMediaPipe() {
            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            hands.setOptions({maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5});
            hands.onResults(onResults);
            
            const cam = new Camera(els.vid, {
                onFrame: async () => { await hands.send({image: els.vid}); },
                width: 1280, height: 720
            });
            cam.start();
        }

        function onResults(results) {
            ctxOver.clearRect(0,0,els.cvsOver.width,els.cvsOver.height);
            
            let lh, rh;
            if (results.multiHandLandmarks) {
                for (const [i, lm] of results.multiHandLandmarks.entries()) {
                    const label = results.multiHandedness[i].label;
                    const isRight = (label === 'Left'); // MP Mirroring: Left label = Right Hand
                    const isLeft = (label === 'Right');

                    if (isLeft) lh = lm;
                    if (isRight) rh = lm;

                    // DRAW MESH
                    drawQuestMesh(lm, isRight);
                }
            }

            // CALIBRATION PHASE
            if (state.phase === 'calibrating') {
                let ok = false;
                if(state.calibStep===0 && lh) ok=true;
                if(state.calibStep===1 && rh) ok=true;
                if(state.calibStep===2 && lh && rh) ok=true;

                if(ok) {
                    state.holdProgress += 2;
                    els.ring.style.transform = `rotate(${state.holdProgress * 3.6}deg)`;
                    if(state.holdProgress > 100) {
                        state.calibStep++;
                        if(state.calibStep > 2) finishCalib();
                        else runCalib();
                    }
                }
            }

            // RUNNING PHASE
            if (state.phase === 'running') {
                
                // RIGHT HAND (Precision Nav)
                if (rh) {
                    // Safe Zone mapping (0.2 - 0.8)
                    let x = 1 - rh[9].x; // Invert X
                    let y = rh[9].y;
                    
                    // Normalize -1 to 1
                    x = (x - 0.5) * 2.5; 
                    y = (y - 0.5) * 2.5;

                    // Apply Sensitivity
                    phys.tarPos.x = x * CONFIG.SENSITIVITY;
                    phys.tarPos.y = -y * (CONFIG.SENSITIVITY * 0.6); // Less vertical sens

                    // Exponential Zoom
                    const pinch = Math.hypot(rh[4].x - rh[8].x, rh[4].y - rh[8].y);
                    // Map 0.02 (closed) to 0.15 (open) -> 0 to 1
                    let normPinch = Math.max(0, (pinch - 0.02) / 0.13);
                    // Exp curve
                    let z = 1.0 + Math.pow(normPinch * 2.5, CONFIG.ZOOM_POW); 
                    phys.tarZoom = Math.min(Math.max(z, CONFIG.ZOOM_MIN), CONFIG.ZOOM_MAX);

                    // Roll
                    const dx = rh[9].x - rh[0].x;
                    const dy = rh[9].y - rh[0].y;
                    phys.tarRot.z = -Math.atan2(dx, dy) * 0.8;

                    els.valZoom.innerText = phys.tarZoom.toFixed(2) + "x";
                    els.fillZoom.style.width = (phys.tarZoom/CONFIG.ZOOM_MAX * 100) + "%";
                }

                // LEFT HAND (Shape)
                if (lh) {
                    let c = 0;
                    if(lh[8].y < lh[6].y) c++;
                    if(lh[12].y < lh[10].y) c++;
                    if(lh[16].y < lh[14].y) c++;
                    if(lh[20].y < lh[18].y) c++;
                    if(Math.abs(lh[4].x - lh[2].x) > 0.06) c++;

                    const shapes = ['Sphere','Heart','Saturn','DNA','Cube','Galaxy'];
                    const s = shapes[c] || 'Sphere';
                    els.valShape.innerText = s;
                    
                    if(s.toLowerCase() !== phys.shape) {
                        phys.shape = s.toLowerCase();
                        updateShape(phys.shape);
                    }
                }
            }
        }

        // --- QUEST MESH DRAWING ---
        function drawQuestMesh(landmarks, isRight) {
            const ctx = ctxOver;
            const w = els.cvsOver.width;
            const h = els.cvsOver.height;

            ctx.lineWidth = 1.5;
            ctx.strokeStyle = CONFIG.MESH_COLOR;
            ctx.fillStyle = CONFIG.MESH_FILL;
            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';

            // Draw Connections (Bones)
            ctx.beginPath();
            for (const c of HAND_CONNECTIONS) {
                const p1 = landmarks[c[0]];
                const p2 = landmarks[c[1]];
                ctx.moveTo(p1.x * w, p1.y * h);
                ctx.lineTo(p2.x * w, p2.y * h);
            }
            ctx.stroke();

            // Draw Joints (Nodes)
            for (const lm of landmarks) {
                ctx.beginPath();
                ctx.arc(lm.x * w, lm.y * h, 3, 0, 2 * Math.PI);
                ctx.fill();
                ctx.stroke();
            }
        }

        // --- THREE.JS ENGINE ---
        function initThree() {
            const scn = new THREE.Scene();
            // No fog, transparent
            const cam = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 100);
            cam.position.z = 24;

            const rend = new THREE.WebGLRenderer({alpha:true, antialias:true});
            rend.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('scene-container').appendChild(rend.domElement);

            // Particles
            const CNT = 10000;
            const geo = new THREE.BufferGeometry();
            const pos = new Float32Array(CNT*3);
            const tar = new Float32Array(CNT*3);
            const col = new Float32Array(CNT*3);
            
            geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            geo.setAttribute('color', new THREE.BufferAttribute(col, 3));

            // Glow Texture
            const cvs = document.createElement('canvas'); cvs.width=64; cvs.height=64;
            const cx = cvs.getContext('2d');
            const g = cx.createRadialGradient(32,32,0,32,32,32);
            g.addColorStop(0,'rgba(255,255,255,1)'); g.addColorStop(0.2,'rgba(255,255,255,0.8)'); g.addColorStop(0.5,'rgba(255,255,255,0.2)'); g.addColorStop(1,'rgba(0,0,0,0)');
            cx.fillStyle=g; cx.fillRect(0,0,64,64);
            const tex = new THREE.Texture(cvs); tex.needsUpdate=true;

            const mat = new THREE.PointsMaterial({size:0.25, map:tex, vertexColors:true, blending:THREE.AdditiveBlending, depthWrite:false, transparent:true});
            const pts = new THREE.Points(geo, mat);
            scn.add(pts);

            // Shape Logic
            window.updateShape = (type) => {
                for(let i=0; i<CNT; i++) {
                    const i3=i*3; const u=Math.random(); const v=Math.random();
                    let x,y,z,r=1,g=1,b=1; const th=2*Math.PI*u; const ph=Math.acos(2*v-1);

                    if (type==='sphere') { x=7*Math.sin(ph)*Math.cos(th); y=7*Math.sin(ph)*Math.sin(th); z=7*Math.cos(ph); r=0.1; g=0.5; b=1; }
                    else if (type==='heart') { const t=u*Math.PI*2; x=16*Math.pow(Math.sin(t),3); y=13*Math.cos(t)-5*Math.cos(2*t)-2*Math.cos(3*t)-Math.cos(4*t); z=(v-0.5)*5; x*=0.4; y*=0.4; z*=0.4; r=1; g=0.1; b=0.4; }
                    else if (type==='saturn') { if(i<CNT*0.3){x=4*Math.sin(ph)*Math.cos(th);y=4*Math.sin(ph)*Math.sin(th);z=4*Math.cos(ph);r=1;g=0.8;b=0.4;}else{const a=u*Math.PI*2;const rd=7+v*5;x=Math.cos(a)*rd;z=Math.sin(a)*rd;y=(Math.random()-0.5)*0.3;r=0.5;g=0.5;b=0.8;} }
                    else if (type==='dna') { const h=(u-0.5)*20; const a=u*Math.PI*10; const rad=3; const o=(i%2===0)?0:Math.PI; x=Math.cos(a+o)*rad; z=Math.sin(a+o)*rad; y=h; if(i%2===0){r=0.2;g=1;b=0.4;}else{r=0.4;g=0.2;b=1;} }
                    else if (type==='cube') { const R=11*Math.cbrt(Math.random()); x=R*Math.sin(ph)*Math.cos(th); y=R*Math.sin(ph)*Math.sin(th); z=R*Math.cos(ph); r=Math.random(); g=Math.random(); b=Math.random(); }
                    else if (type==='galaxy') { const arm=i%3; const s=u*Math.PI*5; const d=v*12; const a=s+(arm*(Math.PI*2/3)); x=Math.cos(a)*d; z=Math.sin(a)*d; y=(Math.random()-0.5)*(12-d)*0.5; r=0.5+u*0.5; g=0.3; b=0.9; }

                    tar[i3]=x; tar[i3+1]=y; tar[i3+2]=z;
                    col[i3]=r; col[i3+1]=g; col[i3+2]=b;
                }
            };
            updateShape('sphere');

            // Animation Loop
            function animate() {
                requestAnimationFrame(animate);

                // Smooth Physics
                phys.pos.lerp(phys.tarPos, CONFIG.SMOOTHING);
                phys.zoom += (phys.tarZoom - phys.zoom) * CONFIG.SMOOTHING;
                phys.rot.z += (phys.tarRot.z - phys.rot.z) * CONFIG.SMOOTHING;
                
                pts.rotation.z = phys.rot.z;
                pts.rotation.y += 0.002;

                // Particle Morph
                const p = geo.attributes.position.array;
                for(let i=0; i<CNT*3; i++) {
                    p[i] += (tar[i]-p[i]) * 0.08;
                }
                geo.attributes.position.needsUpdate = true;
                
                // Camera Transform
                pts.position.copy(phys.pos);
                pts.scale.set(phys.zoom, phys.zoom, phys.zoom);
                
                rend.render(scn, cam);
            }
            animate();

            window.addEventListener('resize', () => {
                cam.aspect = window.innerWidth/window.innerHeight;
                cam.updateProjectionMatrix();
                rend.setSize(window.innerWidth, window.innerHeight);
                els.cvsVid.width = window.innerWidth;
                els.cvsVid.height = window.innerHeight;
                els.cvsOver.width = window.innerWidth;
                els.cvsOver.height = window.innerHeight;
            });
        }
    </script>
</body>
</html>
